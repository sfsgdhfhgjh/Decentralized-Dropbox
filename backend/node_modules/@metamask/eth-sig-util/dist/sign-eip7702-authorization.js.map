{"version":3,"file":"sign-eip7702-authorization.js","sourceRoot":"","sources":["../src/sign-eip7702-authorization.ts"],"names":[],"mappings":";;;AAAA,yCAAyC;AACzC,2CAAqE;AACrE,2CAA6C;AAC7C,yDAAyD;AAEzD,mCAAiE;AAejE;;;;;;;GAOG;AACH,SAAgB,wBAAwB,CAAC,EACvC,UAAU,EACV,aAAa,GAId;IACC,4BAA4B,CAAC,aAAa,CAAC,CAAC;IAE5C,IAAI,IAAA,iBAAS,EAAC,UAAU,CAAC,EAAE;QACzB,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;KACjD;IAED,MAAM,WAAW,GAAG,wBAAwB,CAAC,aAAa,CAAC,CAAC;IAE5D,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,IAAA,aAAM,EAAC,WAAW,EAAE,UAAU,CAAC,CAAC;IAEpD,8DAA8D;IAC9D,MAAM,OAAO,GAAG,IAAA,eAAQ,EAAC,CAAC,CAAC,CAAC;IAE5B,OAAO,IAAA,iBAAS,EAAC,OAAO,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AAClC,CAAC;AArBD,4DAqBC;AAED;;;;;;;;GAQG;AACH,SAAgB,2BAA2B,CAAC,EAC1C,SAAS,EACT,aAAa,GAId;IACC,4BAA4B,CAAC,aAAa,CAAC,CAAC;IAE5C,IAAI,IAAA,iBAAS,EAAC,SAAS,CAAC,EAAE;QACxB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;KAChD;IAED,MAAM,WAAW,GAAG,wBAAwB,CAAC,aAAa,CAAC,CAAC;IAE5D,MAAM,SAAS,GAAG,IAAA,wBAAgB,EAAC,WAAW,EAAE,SAAS,CAAC,CAAC;IAE3D,MAAM,MAAM,GAAG,IAAA,sBAAe,EAAC,SAAS,CAAC,CAAC;IAE1C,OAAO,IAAA,kBAAU,EAAC,MAAM,CAAC,CAAC;AAC5B,CAAC;AApBD,kEAoBC;AAED;;;;;;GAMG;AACH,SAAgB,wBAAwB,CACtC,aAAmC;IAEnC,4BAA4B,CAAC,aAAa,CAAC,CAAC;IAE5C,MAAM,oBAAoB,GAAG,IAAA,YAAM,EAAC,aAAa,CAAC,CAAC;IAEnD,MAAM,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC;QAC5B,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC;QACxB,oBAAoB;KACrB,CAAC,CAAC;IAEH,OAAO,MAAM,CAAC,IAAI,CAAC,IAAA,kBAAS,EAAC,OAAO,CAAC,CAAC,CAAC;AACzC,CAAC;AAbD,4DAaC;AAED;;;;;GAKG;AACH,SAAS,4BAA4B,CAAC,aAAmC;IACvE,IAAI,IAAA,iBAAS,EAAC,aAAa,CAAC,EAAE;QAC5B,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;KACpD;IAED,MAAM,CAAC,OAAO,EAAE,eAAe,EAAE,KAAK,CAAC,GAAG,aAAa,CAAC;IAExD,IAAI,IAAA,iBAAS,EAAC,OAAO,CAAC,EAAE;QACtB,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,CAAC;KAC9C;IAED,IAAI,IAAA,iBAAS,EAAC,eAAe,CAAC,EAAE;QAC9B,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;KACtD;IAED,IAAI,IAAA,iBAAS,EAAC,KAAK,CAAC,EAAE;QACpB,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;KAC5C;AACH,CAAC","sourcesContent":["import { encode } from '@ethereumjs/rlp';\nimport { ecsign, publicToAddress, toBuffer } from '@ethereumjs/util';\nimport { bytesToHex } from '@metamask/utils';\nimport { keccak256 } from 'ethereum-cryptography/keccak';\n\nimport { concatSig, isNullish, recoverPublicKey } from './utils';\n\n/**\n * The authorization struct as defined in EIP-7702.\n *\n * @property chainId - The chain ID or 0 for any chain.\n * @property contractAddress - The address of the contract being authorized.\n * @property nonce - The nonce of the signing account (at the time of submission).\n */\nexport type EIP7702Authorization = [\n  chainId: number,\n  contractAddress: string,\n  nonce: number,\n];\n\n/**\n * Sign an authorization message with the provided private key.\n *\n * @param options - The signing options.\n * @param options.privateKey - The private key to sign with.\n * @param options.authorization - The authorization data to sign.\n * @returns The '0x'-prefixed hex encoded signature.\n */\nexport function signEIP7702Authorization({\n  privateKey,\n  authorization,\n}: {\n  privateKey: Buffer;\n  authorization: EIP7702Authorization;\n}): string {\n  validateEIP7702Authorization(authorization);\n\n  if (isNullish(privateKey)) {\n    throw new Error('Missing privateKey parameter');\n  }\n\n  const messageHash = hashEIP7702Authorization(authorization);\n\n  const { r, s, v } = ecsign(messageHash, privateKey);\n\n  // v is either 27n or 28n so is guaranteed to be a single byte\n  const vBuffer = toBuffer(v);\n\n  return concatSig(vBuffer, r, s);\n}\n\n/**\n * Recover the address of the account that created the given authorization\n * signature.\n *\n * @param options - The signature recovery options.\n * @param options.signature - The '0x'-prefixed hex encoded message signature.\n * @param options.authorization - The authorization data that was signed.\n * @returns The '0x'-prefixed hex address of the signer.\n */\nexport function recoverEIP7702Authorization({\n  signature,\n  authorization,\n}: {\n  signature: string;\n  authorization: EIP7702Authorization;\n}): string {\n  validateEIP7702Authorization(authorization);\n\n  if (isNullish(signature)) {\n    throw new Error('Missing signature parameter');\n  }\n\n  const messageHash = hashEIP7702Authorization(authorization);\n\n  const publicKey = recoverPublicKey(messageHash, signature);\n\n  const sender = publicToAddress(publicKey);\n\n  return bytesToHex(sender);\n}\n\n/**\n * Hash an authorization message according to the signing scheme.\n * The message is encoded according to EIP-7702.\n *\n * @param authorization - The authorization data to hash.\n * @returns The hash of the authorization message as a Buffer.\n */\nexport function hashEIP7702Authorization(\n  authorization: EIP7702Authorization,\n): Buffer {\n  validateEIP7702Authorization(authorization);\n\n  const encodedAuthorization = encode(authorization);\n\n  const message = Buffer.concat([\n    Buffer.from('05', 'hex'),\n    encodedAuthorization,\n  ]);\n\n  return Buffer.from(keccak256(message));\n}\n\n/**\n * Validates an authorization object to ensure all required parameters are present.\n *\n * @param authorization - The authorization object to validate.\n * @throws {Error} If the authorization object or any of its required parameters are missing.\n */\nfunction validateEIP7702Authorization(authorization: EIP7702Authorization) {\n  if (isNullish(authorization)) {\n    throw new Error('Missing authorization parameter');\n  }\n\n  const [chainId, contractAddress, nonce] = authorization;\n\n  if (isNullish(chainId)) {\n    throw new Error('Missing chainId parameter');\n  }\n\n  if (isNullish(contractAddress)) {\n    throw new Error('Missing contractAddress parameter');\n  }\n\n  if (isNullish(nonce)) {\n    throw new Error('Missing nonce parameter');\n  }\n}\n"]}