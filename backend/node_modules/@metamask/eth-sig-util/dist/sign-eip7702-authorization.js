"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashEIP7702Authorization = exports.recoverEIP7702Authorization = exports.signEIP7702Authorization = void 0;
const rlp_1 = require("@ethereumjs/rlp");
const util_1 = require("@ethereumjs/util");
const utils_1 = require("@metamask/utils");
const keccak_1 = require("ethereum-cryptography/keccak");
const utils_2 = require("./utils");
/**
 * Sign an authorization message with the provided private key.
 *
 * @param options - The signing options.
 * @param options.privateKey - The private key to sign with.
 * @param options.authorization - The authorization data to sign.
 * @returns The '0x'-prefixed hex encoded signature.
 */
function signEIP7702Authorization({ privateKey, authorization, }) {
    validateEIP7702Authorization(authorization);
    if ((0, utils_2.isNullish)(privateKey)) {
        throw new Error('Missing privateKey parameter');
    }
    const messageHash = hashEIP7702Authorization(authorization);
    const { r, s, v } = (0, util_1.ecsign)(messageHash, privateKey);
    // v is either 27n or 28n so is guaranteed to be a single byte
    const vBuffer = (0, util_1.toBuffer)(v);
    return (0, utils_2.concatSig)(vBuffer, r, s);
}
exports.signEIP7702Authorization = signEIP7702Authorization;
/**
 * Recover the address of the account that created the given authorization
 * signature.
 *
 * @param options - The signature recovery options.
 * @param options.signature - The '0x'-prefixed hex encoded message signature.
 * @param options.authorization - The authorization data that was signed.
 * @returns The '0x'-prefixed hex address of the signer.
 */
function recoverEIP7702Authorization({ signature, authorization, }) {
    validateEIP7702Authorization(authorization);
    if ((0, utils_2.isNullish)(signature)) {
        throw new Error('Missing signature parameter');
    }
    const messageHash = hashEIP7702Authorization(authorization);
    const publicKey = (0, utils_2.recoverPublicKey)(messageHash, signature);
    const sender = (0, util_1.publicToAddress)(publicKey);
    return (0, utils_1.bytesToHex)(sender);
}
exports.recoverEIP7702Authorization = recoverEIP7702Authorization;
/**
 * Hash an authorization message according to the signing scheme.
 * The message is encoded according to EIP-7702.
 *
 * @param authorization - The authorization data to hash.
 * @returns The hash of the authorization message as a Buffer.
 */
function hashEIP7702Authorization(authorization) {
    validateEIP7702Authorization(authorization);
    const encodedAuthorization = (0, rlp_1.encode)(authorization);
    const message = Buffer.concat([
        Buffer.from('05', 'hex'),
        encodedAuthorization,
    ]);
    return Buffer.from((0, keccak_1.keccak256)(message));
}
exports.hashEIP7702Authorization = hashEIP7702Authorization;
/**
 * Validates an authorization object to ensure all required parameters are present.
 *
 * @param authorization - The authorization object to validate.
 * @throws {Error} If the authorization object or any of its required parameters are missing.
 */
function validateEIP7702Authorization(authorization) {
    if ((0, utils_2.isNullish)(authorization)) {
        throw new Error('Missing authorization parameter');
    }
    const [chainId, contractAddress, nonce] = authorization;
    if ((0, utils_2.isNullish)(chainId)) {
        throw new Error('Missing chainId parameter');
    }
    if ((0, utils_2.isNullish)(contractAddress)) {
        throw new Error('Missing contractAddress parameter');
    }
    if ((0, utils_2.isNullish)(nonce)) {
        throw new Error('Missing nonce parameter');
    }
}
//# sourceMappingURL=sign-eip7702-authorization.js.map